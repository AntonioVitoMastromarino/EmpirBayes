import numpy as np

def normalize(x): return x/x.sum()

def cluster(n:int,N:int,conditional,sample,prior=1,tol=1,maxiter=16):
  posterior=prior
  classification=np.ndarray([N,n])
  gap=tol
  iter=0
  while(gap>tol/(n*np.sqrt(N)) and iter<maxiter):
    likelihoods=np.array([(conditional(x)*posterior).sum() for x in list(sample)])
    classification=np.array([normalize(x) for x in list(likelihoods)])
    gap=((posterior-classification.sum(axis=0))**2).sum()
    posterior=classification.sum(axis=0)
    iter+=1
  return posterior

def calibration(n:int,N:int,conditional,gradient,sample,guess,prior=1,tol=1,maxiter=16):
  posterior=prior
  gap=tol
  iter=0
  parameters=guess
  while(gap>tol/(n*np.sqrt(N)) and iter<maxiter):
    posterior=cluster(n,N,lambda x:conditional(x,parameters),sample,prior=posterior)
    likelihoods=np.array([(conditional(x)*posterior).sum() for x in list(sample)])
    classification=np.array([normalize(x) for x in list(likelihoods)])
    step=(np.array([(gradient(x,parameters)*y).sum() for x,y in list(sample),list(classification)])/likelihoods).sum()
    parameters+=learn*step
